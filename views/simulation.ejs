<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Game Selection</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            overscroll-behavior-y: none;
            margin: 0;
            padding: 0;
            background-color: #1a1a2e;
        }
        canvas {
            display: block;
            background-color: #1a1a2e;
            cursor: grab;
        }
        .scroll-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 20px;
            pointer-events: none;
            opacity: 1;
            transition: opacity 1s ease-in-out;
            z-index: 10;
        }
        .scroll-hint.hidden {
            opacity: 0;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1a1a2e;
            z-index: 100;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <div id="loading" class="loading">
        <div class="spinner"></div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="scrollHint" class="scroll-hint">Scroll to see more games</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scrollHint = document.getElementById('scrollHint');
        const loading = document.getElementById('loading');

        let cards = [];
        let images = [];
        let imagesLoaded = 0;
        let hoveredCardIndex = -1;
        
        let backButton = { x: 0, y: 0, width: 0, height: 0 };
        let isHoveringBackButton = false;

        // Scrolling state
        let scrollY = 0;
        let maxScrollY = 0;
        let isDragging = false;
        let startY_drag = 0;
        let scrollStartY = 0;
        let velocityY = 0;
        let hasMoved = false;
        let lastMoveY = 0;
        let lastMoveX = 0;

        // Game data
        const gameData = [
            { title: "Aftershock Safety Adventure", imgSrc: "images/2das.png", url: "/aftershock" },
            { title: "Chemical Spill Safety Adventure", imgSrc: "images/2dcs.png", url: "/chemicalspill" },
            { title: "Cyclone Safety Adventure", imgSrc: "images/2dcy.png", url: "/cyclone" },
            { title: "Earthquake Safety Adventure", imgSrc: "images/2deq.png", url: "/earthquake" },
            { title: "Fire Drill Adventure", imgSrc: "images/2dfi.png", url: "/fire" },
            { title: "Flood Safety Adventure", imgSrc: "images/2dfd.png", url: "/flood" },
            { title: "Lockdown Safety Adventure", imgSrc: "images/2dlc.png", url: "/lockdown" },
            
        ];

        // Image preloading
        function preloadImages() {
            for (let i = 0; i < gameData.length; i++) {
                images[i] = new Image();
                images[i].onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === gameData.length) {
                        init();
                    }
                };
                images[i].onerror = () => {
                    imagesLoaded++;
                    if (imagesLoaded === gameData.length) {
                        init();
                    }
                }
                images[i].src = gameData[i].imgSrc;
            }
        }

        // Canvas sizing and layout
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            calculateLayout();

            const buttonPadding = 20;
            const buttonWidth = 150;
            const buttonHeight = 50;
            backButton = {
                width: buttonWidth,
                height: buttonHeight,
                x: canvas.width - buttonWidth - buttonPadding,
                y: canvas.height - buttonHeight - buttonPadding,
            };
        }

        function calculateLayout() {
            const cardAspectRatio = 4 / 3;
            const gap = 50;
            const titleAreaHeight = 120;
            
            const cardsPerRow = canvas.width < 1024 ? (canvas.width < 640 ? 1 : 2) : 3;

            const totalGapWidth = (cardsPerRow - 1) * gap;
            const availableWidth = canvas.width - 2 * gap;
            const cardWidth = (availableWidth - totalGapWidth) / cardsPerRow;
            const cardHeight = cardWidth / cardAspectRatio;

            const gridWidth = cardsPerRow * cardWidth + totalGapWidth;
            const startX = (canvas.width - gridWidth) / 2;

            cards = gameData.map((data, i) => {
                let col = i % cardsPerRow;
                const row = Math.floor(i / cardsPerRow);

                if (cardsPerRow === 3 && i === gameData.length - 1 && (gameData.length % 3 === 1)) {
                    col = 1;
                }

                return {
                    x: startX + col * (cardWidth + gap),
                    y: titleAreaHeight + row * (cardHeight + gap),
                    width: cardWidth,
                    height: cardHeight,
                    title: data.title
                };
            });
            
            // Calculate maximum scroll position
            const lastCard = cards[cards.length - 1];
            if (lastCard) {
                const totalHeight = lastCard.y + lastCard.height + gap;
                maxScrollY = Math.max(0, totalHeight - canvas.height);
            } else {
                maxScrollY = 0;
            }
            
            // Hide scroll hint if no scrolling is needed
            if (maxScrollY <= 0) {
                scrollHint.classList.add('hidden');
            } else {
                scrollHint.classList.remove('hidden');
            }
        }

        // Drawing functions
        function drawRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let lines = [];

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = context.measureText(testLine);
                if (metrics.width > maxWidth && n > 0) {
                    lines.push(line);
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line);
            
            const startY = y - (lines.length - 1) * lineHeight / 2;

            lines.forEach((l, i) => {
                 context.fillText(l.trim(), x, startY + i * lineHeight);
            });
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw title
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold ' + Math.min(48, canvas.width / 15) + 'px Poppins';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Explore Our 2D Games', canvas.width / 2, 60);

            ctx.save();
            ctx.translate(0, -scrollY);

            cards.forEach((card, index) => {
                ctx.save();
                
                ctx.fillStyle = '#2c2c54';
                drawRoundedRect(card.x, card.y, card.width, card.height, 15);
                ctx.fill();

                if (index === hoveredCardIndex) {
                    ctx.shadowColor = '#f1c40f';
                    ctx.shadowBlur = 30;
                    ctx.strokeStyle = '#f1c40f';
                    ctx.lineWidth = 4;
                    drawRoundedRect(card.x, card.y, card.width, card.height, 15);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;

                const img = images[index];
                if (img.complete && img.naturalHeight !== 0) {
                    const imgPadding = 15;
                    const textZoneHeight = Math.max(70, card.height * 0.25);
                    const availableHeight = card.height - (imgPadding * 2) - textZoneHeight;
                    const availableWidth = card.width - (imgPadding * 2);
                    const imgAspectRatio = img.naturalWidth / img.naturalHeight;
                    let renderWidth = availableWidth;
                    let renderHeight = renderWidth / imgAspectRatio;
                    if (renderHeight > availableHeight) {
                        renderHeight = availableHeight;
                        renderWidth = renderHeight * imgAspectRatio;
                    }
                    const imgX = card.x + (card.width - renderWidth) / 2;
                    const imgY = card.y + imgPadding;
                    ctx.drawImage(img, imgX, imgY, renderWidth, renderHeight);
                }
                
                // Draw Play Button
                const buttonHeight = Math.max(40, card.height * 0.12);
                const buttonWidth = card.width * 0.6;
                const buttonX = card.x + (card.width - buttonWidth) / 2;
                const buttonY = card.y + card.height - (card.height * 0.25) - 5;
                
                ctx.fillStyle = index === hoveredCardIndex ? '#f39c12' : '#e67e22';
                drawRoundedRect(buttonX, buttonY, buttonWidth, buttonHeight, 10);
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold ' + (buttonHeight * 0.45) + 'px Poppins';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Play', buttonX + buttonWidth / 2, buttonY + buttonHeight / 2);

                // Draw Title Text
                ctx.fillStyle = '#ffffff';
                ctx.font = '600 ' + (card.width / 24) + 'px Poppins';
                ctx.textAlign = 'center';
                const lineHeight = card.width / 22;
                wrapText(ctx, card.title, card.x + card.width / 2, card.y + card.height - (card.height * 0.06), card.width - 30, lineHeight);
                
                ctx.restore();
            });
            ctx.restore();

            // Draw Go Back Button
            ctx.fillStyle = isHoveringBackButton ? '#007bff' : '#0056b3';
            drawRoundedRect(backButton.x, backButton.y, backButton.width, backButton.height, 10);
            ctx.fill();

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 18px Poppins';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Go Back', backButton.x + backButton.width / 2, backButton.y + backButton.height / 2);
        }
        
        // Animation Loop
        function animate() {
            if (!isDragging && Math.abs(velocityY) > 0.1) {
                scrollY += velocityY;
                velocityY *= 0.95;
            } else if (!isDragging) {
                velocityY = 0;
            }

            // Boundary clamping
            if (scrollY < 0) { scrollY = 0; velocityY = 0; }
            if (scrollY > maxScrollY) { scrollY = maxScrollY; velocityY = 0; }
            
            draw();
            requestAnimationFrame(animate);
        }

        // Event Handlers
        function getPos(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function handleDown(clientY) {
            isDragging = true;
            startY_drag = clientY;
            scrollStartY = scrollY;
            hasMoved = false;
            velocityY = 0;
            lastMoveY = clientY;
            canvas.style.cursor = 'grabbing';
        }

        function handleMove(clientX, clientY) {
            if (isDragging) {
                const dy = clientY - startY_drag;
                if (Math.abs(dy) > 5) hasMoved = true;
                scrollY = scrollStartY - dy;
                velocityY = clientY - lastMoveY;
                lastMoveY = clientY;
            }
             lastMoveX = clientX;

            const pos = getPos(clientX, clientY);
            let onCard = false;
            isHoveringBackButton = false;
            hoveredCardIndex = -1;
            
            // Check for back button hover
            if (pos.x >= backButton.x && pos.x <= backButton.x + backButton.width &&
                pos.y >= backButton.y && pos.y <= backButton.y + backButton.height) {
                isHoveringBackButton = true;
            } else {
                 const transformedY = pos.y + scrollY;
                 cards.forEach((card, index) => {
                    if (pos.x >= card.x && pos.x <= card.x + card.width &&
                        transformedY >= card.y && transformedY <= card.y + card.height) {
                        hoveredCardIndex = index;
                        onCard = true;
                    }
                });
            }

            if (!isDragging) {
                canvas.style.cursor = (onCard || isHoveringBackButton) ? 'pointer' : 'grab';
            }
        }

        function handleUp(clientX, clientY) {
            if (!isDragging) return;
            isDragging = false;
            
            if (!hasMoved) {
                const pos = getPos(clientX, clientY);
                
                // Check for back button click
                if (pos.x >= backButton.x && pos.x <= backButton.x + backButton.width &&
                    pos.y >= backButton.y && pos.y <= backButton.y + backButton.height) {
                    window.location.href = '/dashboard';
                    return;
                }

                const transformedY = pos.y + scrollY;
                cards.forEach((card, index) => {
                     if (pos.x >= card.x && pos.x <= card.x + card.width &&
                        transformedY >= card.y && transformedY <= card.y + card.height) {
                         window.location.href = gameData[index].url;
                    }
                });
                velocityY = 0;
            }
            handleMove(clientX, clientY);
        }

        // Mouse wheel event handler - NON-INVERTED
        function handleWheel(e) {
            // Prevent default scrolling behavior
            e.preventDefault();
            
            // Use the wheel delta to adjust scroll position
            // NON-INVERTED: scrolling down moves content down (natural behavior)
            scrollY += e.deltaY;
            
            // Apply momentum for smoother scrolling
            velocityY = e.deltaY * 0.2;
            
            // Boundary clamping
            if (scrollY < 0) { scrollY = 0; velocityY = 0; }
            if (scrollY > maxScrollY) { scrollY = maxScrollY; velocityY = 0; }
            
            // Hide scroll hint after first interaction
            scrollHint.classList.add('hidden');
        }

        // Mouse Events
        canvas.addEventListener('mousedown', e => handleDown(e.clientY));
        canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', e => handleUp(e.clientX, e.clientY));
        
        // Add wheel event listener
        canvas.addEventListener('wheel', handleWheel, { passive: false });

        // Touch Events
        canvas.addEventListener('touchstart', e => {
            if (e.touches.length > 0) handleDown(e.touches[0].clientY);
            e.preventDefault();
        }, { passive: false });
        canvas.addEventListener('touchmove', e => {
            if (e.touches.length > 0) handleMove(e.touches[0].clientX, e.touches[0].clientY);
            e.preventDefault();
        }, { passive: false });
        window.addEventListener('touchend', e => {
            if (e.changedTouches.length > 0) {
                handleUp(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            }
        });

        // Initialization
        function init() {
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            requestAnimationFrame(animate);
            
            // Hide loading screen
            loading.style.display = 'none';
            
            // Hide scroll hint after 5 seconds
            setTimeout(() => {
                scrollHint.classList.add('hidden');
            }, 5000);
        }

        preloadImages();
    </script>
</body>
</html>